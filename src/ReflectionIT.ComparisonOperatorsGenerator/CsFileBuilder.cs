using Microsoft.CodeAnalysis;
using System.CodeDom.Compiler;

namespace ReflectionIT.ComparisonOperatorsGenerator;

public sealed class CsFileBuilder : ICsFileBuilder {
    private bool _isFileScoped;
    private bool _hasNamespace;
    private readonly StringWriter _stringWriter;
    private readonly IndentedTextWriter _indentedTextWriter;

    public CsFileBuilder() {
        _stringWriter = new();
        _indentedTextWriter = new IndentedTextWriter(_stringWriter);
    }

    public ICsFileBuilder AddUsing(string usingStatement) {
        _indentedTextWriter.WriteLine($"using {usingStatement};");
        return this;
    }

    public ICsFileBuilder AddStaticUsing(string usingStatement) {
        _indentedTextWriter.WriteLine($"using static {usingStatement};");
        return this;
    }

    public ICsFileBuilder AddNamespace(string? namespaceName, bool condition = true) {
        if (condition is false || string.IsNullOrEmpty(namespaceName)) {
            return this;
        }

        _hasNamespace = true;

        _indentedTextWriter.WriteLine($"namespace {namespaceName}");
        GoOneLevelInside();
        return this;
    }

    public ICsFileBuilder AddNamespace(INamespaceSymbol namespaceSymbol) {
        return namespaceSymbol.IsGlobalNamespace 
            ? this 
            : AddNamespace(namespaceSymbol.ToDisplayString());
    }

    public ICsFileBuilder AddFileScopedNamespace(string namespaceName, bool condition) {
        if (condition is false) {
            return this;
        }

        _isFileScoped = true;
        _indentedTextWriter.WriteLine($"namespace {namespaceName};");
        return this;
    }

    public ICsFileBuilder AddStatementAndStartBlock(string line) {
        _indentedTextWriter.WriteLine(line);
        GoOneLevelInside();

        return this;
    }

    public ICsFileBuilder AddStatements(params ReadOnlySpan<string> lines) {
        foreach (string line in lines) {
            _indentedTextWriter.WriteLine(line);
        }

        return this;
    }

    public ICsFileBuilder AddStatementsIf(bool condition, params ReadOnlySpan<string> lines) {
        if (condition is false) {
            return this;
        }

        foreach (string line in lines) {
            _indentedTextWriter.WriteLine(line);
        }

        return this;
    }

    public ICsFileBuilder AddEmptyLine(bool condition = true) {
        if (condition is false) {
            return this;
        }

        _indentedTextWriter.WriteLine();
        return this;
    }

    public ICsFileBuilder AddCommentLine(string line) {
        _indentedTextWriter.WriteLine($"//{line}");
        return this;
    }

    public ICsFileBuilder EndBlock() {
        GoOneLevelOutside();
        return this;
    }

    public ICsFileBuilder EndNamespace() {
        if (_isFileScoped || !_hasNamespace) {
            return this;
        }

        GoOneLevelOutside();
        return this;
    }

    public ICsFileBuilder AddIfBlock(string condition, params ReadOnlySpan<string> lines) {
        AddStatementAndStartBlock($"if ({condition})");
        AddStatements(lines);
        GoOneLevelOutside();

        return this;
    }

    public ICsFileBuilder AddAutoGeneratedHeader(string by) {
        AddStatements("//------------------------------------------------------------------------------",
                        "// <auto-generated>",
                       $"//     This code was generated by the {by} source generator",
                        "//     Changes to this file may cause incorrect behavior and will be lost if",
                        "//     the code is regenerated.",
                        "// </auto-generated>",
                        "//------------------------------------------------------------------------------");
        return this;
    }

    public ICsFileBuilder AddPreprocessorDirectives() {
        AddStatements("#pragma warning disable",
                      "#nullable enable annotations");
        return this;
    }

    private void GoOneLevelInside() {
        _indentedTextWriter.WriteLine("{");
        _indentedTextWriter.Indent++;
    }

    private void GoOneLevelOutside() {
        _indentedTextWriter.Indent--;
        _indentedTextWriter.WriteLine("}");
    }

    public string Build() =>
        _stringWriter.ToString();

    public override string ToString() {
        return _indentedTextWriter.ToString();
    }

    public void Dispose() {
        _indentedTextWriter?.Dispose();
        _stringWriter?.Dispose();
    }

    /// <summary>
    /// Add the following attributes
    /// <code>
    /// [global::System.CodeDom.Compiler.GeneratedCode("...", "...")]
    /// [global::System.Diagnostics.DebuggerNonUserCode]
    /// [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    /// </code>
    /// </summary>
    /// <param name="writer">The <see cref="IndentedTextWriter"/> instance to write into.</param>
    /// <param name="generatorName">The name of the generator.</param>
    /// <param name="useFullyQualifiedTypeNames">Whether to use fully qualified type names or not.</param>
    /// <param name="includeNonUserCodeAttributes">Whether to also include the attribute for non-user code.</param>
    public ICsFileBuilder AddGeneratedAttributes(
        string generatorName,
        bool useFullyQualifiedTypeNames = true,
        bool includeNonUserCodeAttributes = true) {
        // We can use this class to get the assembly, as all files for generators are just included
        // via shared projects. As such, the assembly will be the same as the generator type itself.
        Version assemblyVersion = this.GetType().Assembly.GetName().Version;

        if (useFullyQualifiedTypeNames) {
            _indentedTextWriter.WriteLine($$"""[global::System.CodeDom.Compiler.GeneratedCode("{{generatorName}}", "{{assemblyVersion}}")]""");

            if (includeNonUserCodeAttributes) {
                _indentedTextWriter.WriteLine($$"""[global::System.Diagnostics.DebuggerNonUserCode]""");
                _indentedTextWriter.WriteLine($$"""[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]""");
            }
        } else {
            _indentedTextWriter.WriteLine($$"""[GeneratedCode("{{generatorName}}", "{{assemblyVersion}}")]""");

            if (includeNonUserCodeAttributes) {
                _indentedTextWriter.WriteLine($$"""[DebuggerNonUserCode]""");
                _indentedTextWriter.WriteLine($$"""[ExcludeFromCodeCoverage]""");
            }
        }
        return this;
    }

    public ICsFileBuilder AddXmlCommentLines(params ReadOnlySpan<string> lines) {
        foreach (string line in lines) {
            _indentedTextWriter.WriteLine($"/// {line}");
        }
        return this;
    }

    public ICsFileBuilder AddText(string text) {
        _indentedTextWriter.Write(text);

        return this;
    }

    public ICsFileBuilder AddPartial(ITypeSymbol typeSymbol) {
        List<ITypeSymbol> parents = [];

        var parent = typeSymbol.ContainingSymbol as ITypeSymbol;
        while (parent is not null) {
            parents.Add(parent);
            parent = parent.ContainingSymbol as ITypeSymbol;
        }
        parents.Reverse();

        foreach (var item in parents) {
            this.AddStatementAndStartBlock($"partial {TypeDef(item)}");
        }

        this.AddText($"partial {TypeDef(typeSymbol)}");

        return this;

        static string TypeDef(ITypeSymbol typeSymbol) {
            string type = typeSymbol.TypeKind == TypeKind.Interface ? "interface " : typeSymbol.IsValueType ? "struct " : "class ";
            type += typeSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
            if (typeSymbol.IsRecord) {
                type = $"record {type}";
            }
            return type;
        }
    }

    public ICsFileBuilder EndPartial(ITypeSymbol typeSymbol) {
        var parent = typeSymbol.ContainingSymbol as ITypeSymbol;
        while (parent is not null) {
            this.EndBlock();
            parent = parent.ContainingSymbol as ITypeSymbol;
        }
        this.EndBlock();

        return this;
    }
}
